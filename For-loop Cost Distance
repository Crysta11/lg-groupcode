#Install packages
#Load packages
install.packages("secr")
install.packages("gdistance")
install.packages("raster")
install.packages("sp")
install.packages("PopGenReport")
install.packages("gstudio")
install.packages("rgeos")
require(secr)
require(gdistance)
require(raster)
require(sp)
require(PopGenReport)
require(gstudio)
require(rgeos)

#"trick" R into thinking you have enough memory to generate the cd matrix 
memory.limit(size=10000)

#Set working directory to where the raster files are.
#Load a raster

setwd(choose.dir())


Maps<-list.files()	##list all files in the raster directory
length(Maps)
Maps


##Because img files, there are 2 file associations/map, 
##so we will subset to every other


MapOnly<-Maps[c(TRUE, FALSE)]
MapOnly		##should only be img files

##Create Population Function-From LDG homework code

createpops <- function(n, mindist, landscape)
{  
  
  minx <- extent(landscape)@xmin #get the min and max  coordinates
  miny <- extent(landscape)@ymin #coordinates of the landscape
  maxx <- extent(landscape)@xmax
  maxy <- extent(landscape)@ymax
  
  cc<- 1
  coords <- data.frame(lx=NA, ly=NA)
  while (cc<= n )  #repeat until you have found n locations
  {
    draw=FALSE
    while (draw==FALSE)
    {
      x <- runif(1,minx,maxx)
      y <- runif(1,miny,maxy)
      if (landscape[cellFromXY(landscape,c(x,y) )]==1)  draw=TRUE #check if in the habitat
    }
    
    coords[cc,] <- c(x,y)
    
    if (nrow(coords)>1) d <- min(dist(coords)) else d <- mindist+1 
    
    if (d > mindist) cc <- cc+1  #take the location only if distance is larger than mindist
  }
  return( as.matrix( coords))
}

#cd.mat<-NA 
###################Computation intensive############
## for-loop to calculate distance matrices

for(i in 1:length(MapOnly)){
  r <- raster(MapOnly[i])
  
  ##This was in the WK8 lab, I guess we might change this? 
  ##set non-habitat to friction values of 10, and habitat to 1 for Circuit based-analyses
  
  values(r)[(values(r))==1]<-10
  values(r)[(values(r))==0]<-1
  
  #Define Metapopulation.  Again this is from the Wk8 lab.
  para<- list()
  #Define populations (dynamics)
  para$n.pops=100
  para$n.ind=10 #each pop is considered 1 individual
  
  
  #Define cost distance method
  para$method <- "commute" #rSPDdistance, commute
  para$NN <- 8  #number of neighbours for the cost distance method ### I think this is direction moveable through cells-I set it to 8
  
  # A)    init simulation populations from scratch
  landscape<- r  #<-raster(system.file("external/rlogo.grd", package="raster"))
  
  #Define x and y locations
  para$locs <-createpops(n=para$n.pops, mindist = 3, landscape = r)
  
  
  #Create convex hull
  
  conhull <- SpatialPoints(para$locs)
  hull <- gConvexHull(conhull)
  
  hullbuffer <- gBuffer(hull, width=10000)
  landscape<-crop(r,hullbuffer)
  
  
  
  initial<-NA
  for(j in 1:(para$n.pops*para$n.ind)){
    init<-paste(c("initial",j),sep="",collapse="")
    initial<-na.omit(rbind(initial,init))
  } 
  
  
  Individuals<-data.frame(1:para$n.pops,rep(para$locs[,1],para$n.ind),rep(para$locs[,2],para$n.ind),initial[,1],
                          sample(c(0,1),para$n.pops*para$n.ind,replace=TRUE),50,1:(para$n.pops*para$n.ind),100,0,0,0,0,0,0,0,0,0)
  
  colnames(Individuals)<-c("Subpopulation","lx","ly","ID","sex","Fitness_AA","Fitness_Aa","Fitness_aa","Fitness_AABB",
                           "Fitness_AaBB","Fitness_aaBB","Fitness_AABb","Fitness_AaBb","Fitness_aaBb","Fitness_AAbb","Fitness_Aabb","Fitness_aabb")
  
  write.csv(Individuals, file =paste(c("C:\\Users\\nba52\\Desktop\\XY",MapOnly[i],".csv"),sep="",collapse=""), row.names = FALSE)
 
  #create a costdistance matrix 
  cost.mat <- costdistances(landscape, para$locs, para$method, para$NN) #needed for the simulation
  
  model<-cost.mat

  Ind<-matrix(NA,ncol=length(Individuals$Subpopulation),nrow=length(Individuals$Subpopulation)) ##Create a null matrix of length of individuals
  for(i in 1:length(Individuals$Subpopulation)){
    
    for(j in 1:length(Individuals$Subpopulation)){
      
      Ind[i,j]<-model[Individuals[i,1],Individuals[j,1]]
    }
  }
  
  
  #Create a .table file that can be used by CDPOP  
  #Write.table allows you to eliminate column names whereas write.csv does not
  write.table(cost.mat, file =paste(c("C://Users//nba52//Desktop//","costdistance",MapOnly[i],".csv"),sep="",collapse=""),row.names=FALSE, na="",col.names=FALSE, sep=",")
  
}
