#Install packages
#Load packages
require(PopGenReport)
require(secr)
require(gdistance)
require(raster)

#Load a raster
setwd(choose.dir()) ##set your working directory where the maps are

Surfaces<-list.files()
num_files<-length(Surfaces)
num_files

#Create function to put populations on the raster. 

createpops <- function(n, mindist, landscape, plot=TRUE)
{  
  
  minx <- extent(landscape)@xmin #get the min and max  coordinates
  miny <- extent(landscape)@ymin #coordinates of the landscape
  maxx <- extent(landscape)@xmax
  maxy <- extent(landscape)@ymax
  
  cc<- 1
  coords <- data.frame(lx=NA, ly=NA)
  while (cc<= n )  #repeat until you have found n locations
  {
    draw=FALSE
    while (draw==FALSE)
    {
      x <- runif(1,minx,maxx)
      y <- runif(1,miny,maxy)
      if (landscape[cellFromXY(landscape,c(x,y) )]==1)  draw=TRUE #check if in the habitat
    }
    
    coords[cc,] <- c(x,y)
    
    if (nrow(coords)>1) d <- min(dist(coords)) else d <- mindist+1 
    
    if (d > mindist) cc <- cc+1  #take the location only if distance is larger than mindist
  }
  if (plot==TRUE) 
  {
    plot(landscape)  
    points(coords, pch=16)
  }
  return( as.matrix( coords))
}

#Define Metapopulation.  Again this is from the Wk8 lab.
para<- list()
#Define populations (dynamics)
para$n.pops=100 ##set eachpop to be an individual
para$n.ind=1 ##doing this for individuals


#Define cost distance method
para$method <- "rSPDdistance" #rSPDdistance, commute rSPDdistance is akin to Circuitscape
para$NN <- 8  #number of neighbours for the cost distance method


#"trick" R into thinking you have enough memory to generate the cd matrix 

memory.limit(size=10000)

for (i in 1:num_files){
  
  r <- raster(Surfaces[i])
  
 
  # A)    init simulation populations from scratch
  landscape<- r  #<-raster(system.file("external/rlogo.grd", package="raster"))
  
  
  #Define x and y locations
  para$locs <-createpops(n=para$n.pops, mindist = 3, landscape = r, plot = TRUE)
  #give the population some names 
  rownames(para$locs) <- c(1:para$n.pops)

  #create a costdistance matrix 
  cost.mat <- costdistances(landscape, para$locs, para$method, para$NN) #needed for the simulation
  ##I haven't tried this one yet:  eucl.mat <- as.matrix(dist(para$locs))  #needed for the analysis later
  
  
  #Create a .csv file that can be used by CDPOP  ##I don't know how to get rid of the column names
  write.csv(cost.mat, file=paste(c(gewtd(),Surfaces[i],"testcdmatrix.csv"),sep="",collapse=""), row.names = FALSE, colnames=FALSE)
  
  #csv file of the yx coordinates of the populations
  write.csv(para$locs, file = paste(c(gewtd(),Surfaces[i],"XYtest.csv"),collapse="",sep="")
  }
